#pragma config(Sensor, S1,     touchSensor,    sensorEV3_Touch)
#pragma config(Sensor, S2,     gyroSensor,     sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          armMotor,      tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          lm,     tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          rm,       tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#define MAX_POINTS 100 // max points
#define MAX_DISTANCE 1000000000 // max distance
#define INF 987654321


typedef struct Point {
   int r;
   int c;
} Point;


float Calculate(Point point1, Point point2){ // calculating distance
   return abs((point1.r + point1.c) - (point2.r + point2.c));
}

int minPoint(Point point1, Point point2) // using in findDt method
{
   return min(point1.r, point2.r), min(point1.c, point2.c);
}

int maxPoint(Point point1, Point point2) // using in findDt method
{
   return max(point1.r, point2.r), max(point1.c, point2.c);
}

float findShortestDistance(Point currentPosition, Point redPoint, int redPointCount){ // shortdistance from current to nextred
   float shortestDistance = MAX_DISTANCE;

   for (int i = 0; i < redPointCount; i++){ // what is redPointCount?
      float distance = Calculate(currentPosition, redPoint); // caculating distance from current to redPoint
      if (distance < shortestDistance) { // if on this distance is shorter than shortdistance
         shortestDistance = distance; // change shorterdistance
      }
   }

   return shortestDistance; // fix!!
}


Point currentPosition = {0, 0};
bool isPointZero(Point point){ // judging, is it 0, 0.
   return (point.r == 0 && point.c == 0);
}

void bell_ford(int grid, Point start, Point end){
   int rows = len(grid);
   int cols = len(grid[0]);
   float distance[rows][cols];


   for (int i = 0; i < rows; i++)
   {
      for (int j = 0; j < cols; j++)
      {
         distance[i][j] = grid[i][j];
      }
   }
}



// This method calculates the weight from the current location to the red patch located
//  at the shortest distance to helps the robot achieve optimal movement.

int findDt(Point start, Point end, int arr[6][6])
{ // !! S: information about the patch, Dt: information about weights.

/* you don't need to look at this comments
   // int start_r, start_c, end_r, end_c; // redefine Pointing spot.

   // for(int i=0; i<6; i++) // define INF array
   // {
   //    for(int j=0; j<6; j++)
   //    {
   //       smallDt[i][j] = INF;
   //    }
   // }


   // if (start.r>end.r && start.c>end.c) // redefine startingPoint, endingPoint
   // {
   //    start_r = start.r;
   //    end_r = end.r;
   //    start_c = start.c;
   //    end_c = end.c;
   // }
   // else if(start.r<end.r && start.c<end.c)
   // {
   //    start_r = end.r;
   //    end_r = start.r;
   //    start_c = end.c;
   //    end_c = start.c;
   // }

   // if (start.c>end.c)
   // {  
   //    start_c = start.c;
   //    end_c = end.c;
   // }
   // else
   // {
   //    start_c = end.c;
   //    end_c = end.c;
   // }
*/

   int Small_r, Small_c, Large_r, Large_c;
   
   Small_r, Small_c = minPoint(start, end);
   Large_r, Large_c = maxPoint(start, end);

   Point array_Start = {Small_r, Small_c}; // start point of the original array
   Point array_End = {Large_r, Large_c}; // end point of the original array

   int size_r = abs(start.r - end.r) + 1; // array r_size
   int size_c = abs(start.c - end.c) + 1; // array c_size

   int smallDt[size_r][size_c]; // define small_array of Dt
   int smallS[size_r][size_c]; // define small_array of S

   for (int i = 0; i < size_r; i++) // Bring the patch of original array. In smallS
   {
      for (int j = 0; j < size_c; j++)
      {
         smallS[i][j] = arr[array_Start.r + i][array_Start.c + j]; // !!! why arr is error? because of fucking pointer!?
      }
   }


   for(int i=0; i<array_End.r+1; i++) // Weight calculation about small array.
   {
      for(int j=0; j<array_End.c+1; j++)
         {
         if(i==0 && j==0) smallDt[i][j] = smallS[i][j];
         else if(i==0) smallDt[i][j] = smallDt[i][j-1] + smallS[i][j];
         else if(j==0) smallDt[i][j] = smallDt[i-1][j] + smallS[i][j];
         else smallDt[i][j] = max(smallDt[i-1][j], smallDt[i][j-1]) + smallS[i][j];
         }
   }

   return smallDt; // return an array of weights to go from (start point) to (end point)
}

void gotoNextRedpatch(int dt[6][6], Point start_p, Point end_p)
{
   int start_r = start_p.r;
   int start_c = start_p.c;
   int end_r = end_p.r;
   int end_c = end_p.c;

   while(start_r != end_r && start_c != end_c)
   {
      if(start_r > 1)
      if(r==0) goRight();
      else if(dt[r-1][c] > dt[r][c-1]) goUp(); // Up_value is bigger than Left_value
      // else if(dt[r-1][c] == dt[r][c-1]) // Up/Left_value is same
      // {
      //    int a = cases(r-1, c, dt[r-1][c]); // S_Up_dt_time
      //    int b = cases(r, c-1, dt[r][c-1]); // S_Left_time
      //    if(a > b) goLeft(); // S_Up_time is long, goL
      //    else goUp(); // S-Left_time is long, goU
      // }
      else if(dt[r][c+1] > dt[r][c]) goRight();
      else goRight(); // Left_value is bigger than Up_value hmm,,, fuck?? oh that's ok.
      eraseDisplay();

   }
}

task main()
{
   Point redPoint[MAX_POINTS];
   int redPointCount = 0; //add points // is this the number of redPoint?

   for (int i = 0; i < 5; i++){ // oh, is this mapping of redPoint?
      for (int j = 0; j < 5; j++){
         if (colorMapping[i][j] == 1){ // if red. oh, 2 is red?
            redPoint[redPointCount].r = i;
            redPoint[redPointCount].c = j;
            redPointCount++;}
      }
   }
   //redPoint location store.
   findShortestDistance();
   ff();



}