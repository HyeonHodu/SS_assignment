#pragma config(Sensor, S1,     touchSensor,    sensorEV3_Touch)
#pragma config(Sensor, S2,     gyroSensor,     sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          armMotor,      tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          lm,     tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          rm,	    tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#define MAX_POINTS 100 // max points
#define MAX_DISTANCE 1000000000 // max distance
#define INF 987654321


typedef struct Point {
   int r;
   int c;
} Point;

Point currentPoint = {0, 0};
Point FinishPoint = {0, 0};
Point redPoint;
int redCount = 0;
int colorMapping[5][5];

float Calculate(Point point1, Point point2){ // calculating distance
   return abs((point1.r + point1.c) - (point2.r + point2.c));
}

int minPoint(Point point1, Point point2) // using in findDt method
{
   return min(point1.r, point2.r), min(point1.c, point2.c);
}

int maxPoint(Point point1, Point point2) // using in findDt method
{
   return max(point1.r, point2.r), max(point1.c, point2.c);
}


Point findShortestDistance(Point currentPosition, Point redPoint[], int redPointCount){ // send redPoint array. compare each elements
	float shortestDistance = MAX_DISTANCE;
	Point shortest_redPatch;

	for (int i = 0; i < redPointCount; i++){
		float distance = Calculate(currentPosition, redPoint[i]);
		if (distance < shortestDistance) {
			shortestDistance = distance;
			shortest_redPatch.r = redPoint[i].r;
			shortest_redPatch.c = redPoint[i].c;
		}
	}

	return shortest_redPatch; // it returns shortest_redPatch location x, y
}


bool isPointZero(Point point){ // judging, is it 0, 0.
   return (point.r == 0 && point.c == 0);
}



// This method calculates the weight from the current location to the red patch located
//  at the shortest distance to helps the robot achieve optimal movement.

int findDt(Point start, Point end, int arr[5][5])
{ // !! S: information about the patch, Dt: information about weights.

   int Small_r, Small_c, Large_r, Large_c;
   
   Small_r, Small_c = minPoint(start, end); 
   Large_r, Large_c = maxPoint(start, end); 

   Point array_Start = {Small_r, Small_c};
   Point array_End = {Large_r, Large_c};

   int size_r = abs(start.r - end.r) + 1;
   int size_c = abs(start.c - end.c) + 1;

   int smallDt[size_r][size_c];
   int smallS[size_r][size_c];

   for (int i = 0; i < size_r; i++) // Bring the patch of original array. In smallS
   {                                
      for (int j = 0; j < size_c; j++)
      {
         smallS[i][j] = arr[array_Start.r + i][array_Start.c + j];
      }
   }


   if(start.r > end.r && start.c > end.c) // direction Left and Up 
   {
      for(int i=start.r; i>=end.r; i--) // Weight calculation about small array.
	   {
		   for(int j=start.c; j>=end.c; j--)
			   {
			   if(i==start.r && j==start.c) smallDt[i][j] = smallS[i][j];
			   else if(i==start.r) smallDt[i][j] = smallDt[i][j+1] + smallS[i][j]; // 
			   else if(j==start.c) smallDt[i][j] = smallDt[i+1][j] + smallS[i][j]; // 
			   else smallDt[i][j] = max(smallDt[i+1][j], smallDt[i][j+1]) + smallS[i][j];
		   	}
	   }
   }
   else if(start.r > end.r) // direction Up and... 
   {
      if(start.c < end.c) // direction U
      {
         for(int i=start.r; i>=end.r; i--)
	      {
		      for(int j=start.c; j<=end.c; j++)
			      {
			      if(i==start.r && j==start.c) smallDt[i][j] = smallS[i][j];
			      else if(i==start.r) smallDt[i][j] = smallDt[i][j-1] + smallS[i][j]; 
			      else if(j==start.c) smallDt[i][j] = smallDt[i+1][j] + smallS[i][j]; 
			      else smallDt[i][j] = max(smallDt[i+1][j], smallDt[i][j-1]) + smallS[i][j];
		   	   }
	      }
      }
      else // start.c==end.c. because of (start.r > end.r) is included Left and Up. direction Up.
      {    // 
         for(int i=start.r; i>=end.r; i--)
	      {
		      for(int j=start.c; j<=end.c; j--)
			      {
			      if(i==start.r && j==start.c) smallDt[i][j] = smallS[i][j];
			      else smallDt[i][j] = smallDt[i+1][j] + smallS[i][j];
		   	   }
	      }
      }
   }
   else if(start.r < end.r) // direction down and Left 
   {                        
      for(int i=start.r; i<=end.r; i++) // Weight calculation about small array.
	   {
		   for(int j=start.c; j>=end.c; j--)
			   {
			   if(i==start.r && j==start.c) smallDt[i][j] = smallS[i][j];
			   else if(i==start.r) smallDt[i][j] = smallDt[i][j+1] + smallS[i][j]; 
			   else if(j==start.c) smallDt[i][j] = smallDt[i-1][j] + smallS[i][j]; 
			   else smallDt[i][j] = max(smallDt[i-1][j], smallDt[i][j+1]) + smallS[i][j];
		   	}
	   }
   }
   else // start.r == end.r direction Left 
   {
      for(int i=start.r; i>=end.r; i--) // Weight calculation about small array.
	   {
		   for(int j=start.c; j>=end.c; j--)
			   {
			   if(i==start.r && j==start.c) smallDt[i][j] = smallS[i][j];
			   else smallDt[i][j] = smallDt[i][j+1] + smallS[i][j];
		   	}
	   }
   }


   if (smallDt[end.r][end.c] > 0)
   {
      return smallDt; // return an array of weights to go from (start point) to (end point)
   }
   else if(smallDt[end.r][end.c] == 0)
   {
      return 1; //
   }
   else
   {
      return 0; // False. Don't visit this redPatch
   }
}




void gotoNextRedpatch(int dt[5][5], Point start_p, Point end_p)
{
   int start_r = start_p.r;
   int start_c = start_p.c;
   int end_r = end_p.r;
   int end_c = end_p.c;

   while(start_r != end_r && start_c != end_c)
	{
      if(start_r > end_r && start_c > end_c) // move (left)+(up)
      {
         if(dt[start_r-1][start_c] > dt[start_r][start_c-1]) // Left is bigger than Up
         {
            start_c -= 1; // goLeft
            // 
         }
         else if(dt[start_r-1][start_c] < dt[start_r][start_c-1]) // Up is bigger than Left
         {
            start_r -= 1; // goUp
            // 
         }
         else // if (Left, Up) is same?????
         {
            start_c -= 1; // goLeft
            // 
         }
      }
		else if(start_r > end_r) // move Up... 
      {
         if(start_c < end_c) // 
         {
            if(dt[start_r-1][start_c] < dt[start_r][start_c+1]) // 
            {
               start_c += 1; // goRight
               // 
            }
            else if(dt[start_r-1][start_c] > dt[start_r][start_c+1]) //
            {
               start_r -= 1; // goUp
               // 
            }
            else
            {
               start_c += 1; // goRight
               // 
            }
         }
         else
         {
            start_r -= 1; // goUp
         }
      }
      else if(start_r < end_r) // 
      {
         if(dt[start_r-1][start_c] > dt[start_r][start_c-1])
         {
            start_c -= 1; // goLeft
            // 
         }
         else if(dt[start_r-1][start_c] < dt[start_r][start_c+1])
         {
            start_r += 1; // goRight
            // 
         }
      }
      else // 
      {
         start_c -= 1;
         // 
      }

		eraseDisplay();

	}
}

task main()
{
   int redPatchMap[5][5]; 
   int redlastRow = -1, redlastCol = -1;
   int mapsize_r = 0, mapsize_c = 0;
   int k = 0;
   Point redPatch[redCount];

   for (int i = 0; i < 5; ++i) {
       for (int j = 0; j < 5; ++j) {
           if (colorMapping[i][j] == 1) { 
               redPatchMap[i][j] = 1;
               redPatch[k].r = i;
               redPatch[k].c = j;
               k += 1;
           }
       }
   }


   for (int i = 0; i < 5; ++i) {
       for (int j = 0; j < 5; ++j) {
           if (redPatchMap[i][j] == 1) {
               redlastRow = i;
               redlastCol = j;
           }
       }
   }

   while(currentPoint.r != 0 && currentPoint.c != 0)
   {
      if(redCount == 0)
      {
         mapsize_r = abs(currentPoint.r- FinishPoint.r) + 1;
         mapsize_c = abs(currentPoint.c- FinishPoint.c) + 1;
         int arr[mapsize_r][mapsize_c] = findDt(currentPoint, FinishPoint, colorMapping);
         gotoNextRedpatch(arr, currentPoint, FinishPoint);
      }
      else if(redCount > 0)
      {
         redPoint = findShortestDistance(currentPoint, redPatch, redCount);
         if(findDt(currentPoint, redPoint, colorMapping) == 0)
         {
            colorMapping[redPoint.r][redPoint.c] = -1;
            redPatchMap[redPoint.r][redPoint.c] = 0;
         }
         else if(findDt(currentPoint, redPoint, colorMapping) == 1)
         {
            colorMapping[redPoint.r][redPoint.c] = 0;
         }
         else
         {
            int arr = findDt(currentPoint, redPoint, colorMapping[5][5]);
            gotoNextRedpatch(arr, currentPoint, redPoint);
            currentPoint = redPoint; 
         }
      }
   }


   
   //redPoint location store.
   findShortestDistance();
   ff();

   



}
